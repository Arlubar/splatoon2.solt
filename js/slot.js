var strFileName = "Wst_Charger_Keeper_00|Wst_Charger_Keeper_01|Wst_Charger_Light_00|Wst_Charger_Light_01|Wst_Charger_Long_00|Wst_Charger_Long_01|Wst_Charger_LongScope_00|Wst_Charger_LongScope_01|Wst_Charger_Normal_00|Wst_Charger_Normal_01|Wst_Charger_Normal_H|Wst_Charger_NormalScope_00|Wst_Charger_NormalScope_01|Wst_Charger_Quick_00|Wst_Charger_Quick_01|Wst_Roller_BrushMini_00|Wst_Roller_BrushMini_01|Wst_Roller_BrushNormal_00|Wst_Roller_BrushNormal_01|Wst_Roller_BrushNormal_H|Wst_Roller_Compact_00|Wst_Roller_Compact_01|Wst_Roller_Heavy_00|Wst_Roller_Heavy_01|Wst_Roller_Hunter_00|Wst_Roller_Hunter_01|Wst_Roller_Normal_00|Wst_Roller_Normal_01|Wst_Roller_Normal_H|Wst_Shooter_BlasterLight_00|Wst_Shooter_BlasterLight_01|Wst_Shooter_BlasterLightLong_00|Wst_Shooter_BlasterLightLong_01|Wst_Shooter_BlasterLightShort_00|Wst_Shooter_BlasterLightShort_01|Wst_Shooter_BlasterLong_00|Wst_Shooter_BlasterLong_01|Wst_Shooter_BlasterMiddle_00|Wst_Shooter_BlasterMiddle_01|Wst_Shooter_BlasterMiddle_H|Wst_Shooter_BlasterShort_00|Wst_Shooter_BlasterShort_01|Wst_Shooter_Blaze_00|Wst_Shooter_Blaze_01|Wst_Shooter_Expert_00|Wst_Shooter_Expert_01|Wst_Shooter_First_00|Wst_Shooter_First_01|Wst_Shooter_Flash_00|Wst_Shooter_Flash_01|Wst_Shooter_Gravity_00|Wst_Shooter_Gravity_01|Wst_Shooter_Heavy_00|Wst_Shooter_Heavy_01|Wst_Shooter_Long_00|Wst_Shooter_Long_01|Wst_Shooter_Normal_00|Wst_Shooter_Normal_01|Wst_Shooter_Normal_H|Wst_Shooter_Precision_00|Wst_Shooter_Precision_01|Wst_Shooter_QuickMiddle_00|Wst_Shooter_QuickMiddle_01|Wst_Shooter_Short_00|Wst_Shooter_Short_01|Wst_Shooter_TripleMiddle_00|Wst_Shooter_TripleMiddle_01|Wst_Shooter_TripleQuick_00|Wst_Shooter_TripleQuick_01|Wst_Slosher_Diffusion_00|Wst_Slosher_Diffusion_01|Wst_Slosher_Launcher_00|Wst_Slosher_Launcher_01|Wst_Slosher_Strong_00|Wst_Slosher_Strong_01|Wst_Slosher_Strong_H|Wst_Spinner_Hyper_00|Wst_Spinner_Hyper_01|Wst_Spinner_Quick_00|Wst_Spinner_Quick_01|Wst_Spinner_Standard_00|Wst_Spinner_Standard_01|Wst_Spinner_Standard_H|Wst_Twins_Dual_00|Wst_Twins_Dual_01|Wst_Twins_Gallon_00|Wst_Twins_Gallon_01|Wst_Twins_Normal_00|Wst_Twins_Normal_01|Wst_Twins_Normal_H|Wst_Twins_Short_00|Wst_Twins_Short_01|Wst_Twins_Stepper_00|Wst_Twins_Stepper_01|Wst_Umbrella_Normal_00|Wst_Umbrella_Normal_01|Wst_Umbrella_Normal_H|Wsb_Bomb_Curling_00|Wsb_Bomb_Quick_00|Wsb_Bomb_Robo_00|Wsb_Bomb_Splash_00|Wsb_Bomb_Suction_00|Wsb_Flag_00|Wsb_PointSensor_00|Wsb_PoisonFog_00|Wsb_Shield_00|Wsb_Sprinkler_00|Wsb_TimerTrap_00|Wsp_AquaBall_00|Wsp_Jetpack_00|Wsp_LauncherCurling_00|Wsp_LauncherQuick_00|Wsp_LauncherRobo_00|Wsp_LauncherSplash_00|Wsp_LauncherSuction_00|Wsp_RainCloud_00|Wsp_SuperArmor_00|Wsp_SuperBubble_00|Wsp_SuperLanding_00|Wsp_SuperMissile_00|Wsp_WaterCutter_00|Hed_AMB_000|Hed_AMB_001|Hed_AMB_002|Hed_AMB_003|Hed_AMB_004|Hed_AMB_005|Hed_CAP_000|Hed_CAP_001|Hed_CAP_002|Hed_CAP_005|Hed_CAP_006|Hed_CAP_007|Hed_CAP_009|Hed_CAP_014|Hed_CAP_019|Hed_CAP_020|Hed_CAP_023|Hed_COP_100|Hed_EYE_000|Hed_EYE_002|Hed_EYE_003|Hed_EYE_005|Hed_EYE_007|Hed_EYE_008|Hed_EYE_011|Hed_FST_000|Hed_HAT_000|Hed_HAT_002|Hed_HAT_003|Hed_HAT_004|Hed_HAT_005|Hed_HAT_008|Hed_HAT_009|Hed_HBD_002|Hed_HBD_003|Hed_HBD_005|Hed_HDP_000|Hed_HDP_002|Hed_HDP_003|Hed_MET_000|Hed_MET_005|Hed_MET_006|Hed_MET_007|Hed_MSK_001|Hed_MSK_003|Hed_MSK_004|Hed_MSK_005|Hed_MSK_007|Hed_MSK_008|Hed_MSK_009|Hed_MSN_000|Hed_MSN_004|Hed_MSN_101|Hed_NCP_000|Hed_NCP_002|Hed_NCP_004|Hed_NCP_008|Hed_NCP_009|Hed_VIS_001|Hed_VIS_002|Hed_VIS_003|Clt_AMB_000|Clt_AMB_001|Clt_AMB_002|Clt_AMB_003|Clt_AMB_004|Clt_AMB_005|Clt_COP_100|Clt_COP_101|Clt_COP_102|Clt_FST_001|Clt_HAP_001|Clt_JKT_002|Clt_JKT_003|Clt_JKT_006|Clt_JKT_007|Clt_JKT_012|Clt_JKT_014|Clt_JKT_017|Clt_JKT_018|Clt_JKT_019|Clt_JKT_020|Clt_JKT_021|Clt_JKT_022|Clt_JKT_024|Clt_JKT_026|Clt_JKT_027|Clt_JKT_028|Clt_JKT_030|Clt_JKT_031|Clt_MSN_000|Clt_MSN_004|Clt_MSN_101|Clt_PLO_000|Clt_PLO_006|Clt_PLO_007|Clt_PLO_008|Clt_PRK_000|Clt_PRK_002|Clt_PRK_004|Clt_PRK_005|Clt_PRK_006|Clt_SHT_002|Clt_SHT_004|Clt_SHT_007|Clt_SHT_010|Clt_SHT_012|Clt_SHT_015|Clt_SHT_017|Clt_SHT_018|Clt_SHT_019|Clt_SHT_020|Clt_SHT_021|Clt_SHT_022|Clt_SWT_002|Clt_SWT_005|Clt_SWT_006|Clt_SWT_007|Clt_SWT_008|Clt_SWT_009|Clt_TEL_001|Clt_TEL_002|Clt_TEL_003|Clt_TEL_004|Clt_TEL_007|Clt_TEL_013|Clt_TEL_014|Clt_TEL_015|Clt_TEL_016|Clt_TEL_017|Clt_TES_000|Clt_TES_001|Clt_TES_006|Clt_TES_007|Clt_TES_010|Clt_TES_011|Clt_TES_013|Clt_TES_015|Clt_TES_019|Clt_TES_020|Clt_TES_022|Clt_TES_030|Clt_TES_031|Clt_TES_032|Clt_TES_033|Clt_TES_034|Clt_TES_035|Clt_TES_036|Clt_TES_037|Clt_TES_038|Clt_TES_039|Clt_TES_040|Clt_TES_041|Clt_TES_042|Clt_TES_043|Clt_TES_044|Clt_TES_045|Clt_TLY_001|Clt_TLY_004|Clt_TLY_005|Clt_TLY_006|Clt_TLY_008|Clt_TLY_009|Clt_TLY_010|Clt_TLY_011|Clt_TNK_001|Clt_TNK_003|Clt_TNK_004|Clt_TNK_005|Clt_VST_002|Clt_VST_003|Shs_AMB_000|Shs_AMB_001|Shs_AMB_002|Shs_AMB_003|Shs_AMB_004|Shs_AMB_005|Shs_BOT_000|Shs_BOT_003|Shs_BOT_005|Shs_BOT_006|Shs_BOT_012|Shs_BOT_013|Shs_CFS_000|Shs_CFS_001|Shs_FST_000|Shs_LTS_000|Shs_LTS_001|Shs_LTS_004|Shs_LTS_005|Shs_LTS_006|Shs_MSN_000|Shs_MSN_004|Shs_MSN_101|Shs_SDL_000|Shs_SDL_001|Shs_SDL_003|Shs_SDL_004|Shs_SDL_005|Shs_SHI_000|Shs_SHI_003|Shs_SHI_004|Shs_SHI_006|Shs_SHI_009|Shs_SHI_011|Shs_SHI_012|Shs_SHI_013|Shs_SHI_014|Shs_SHI_015|Shs_SHI_016|Shs_SHI_017|Shs_SHI_018|Shs_SHI_019|Shs_SHI_020|Shs_SHT_000|Shs_SHT_001|Shs_SHT_002|Shs_SHT_007|Shs_SHT_008|Shs_SHT_009|Shs_SHT_011|Shs_SHT_012|Shs_SHT_013|Shs_SHT_014|Shs_SLO_003|Shs_SLO_008|Shs_SLO_009|Shs_SLO_011|Shs_SLO_012|Shs_SLO_013|Shs_SLP_000|Shs_TRS_000|Shs_TRS_002";
//var strFileName = "Wst_Charger_Keeper_00|Wst_Charger_Keeper_01|Wst_Charger_Light_00|Wst_Charger_Light_01|Wst_Charger_Long_00|Wst_Charger_Long_01|Wst_Charger_LongScope_00|Wst_Charger_LongScope_01|Wst_Charger_Normal_00|Wst_Charger_Normal_01|Wst_Charger_Normal_H|Wst_Charger_NormalScope_00|Wst_Charger_NormalScope_01|Wst_Charger_Quick_00|Wst_Charger_Quick_01|Wst_Roller_BrushMini_00|Wst_Roller_BrushMini_01|Wst_Roller_BrushNormal_00|Wst_Roller_BrushNormal_01|Wst_Roller_BrushNormal_H|Wst_Roller_Compact_00|Wst_Roller_Compact_01|Wst_Roller_Heavy_00|Wst_Roller_Heavy_01|Wst_Roller_Hunter_00|Wst_Roller_Hunter_01|Wst_Roller_Normal_00|Wst_Roller_Normal_01|Wst_Roller_Normal_H|Wst_Shooter_BlasterLight_00|Wst_Shooter_BlasterLight_01|Wst_Shooter_BlasterLightLong_00|Wst_Shooter_BlasterLightLong_01|Wst_Shooter_BlasterLightShort_00|Wst_Shooter_BlasterLightShort_01|Wst_Shooter_BlasterLong_00|Wst_Shooter_BlasterLong_01|Wst_Shooter_BlasterMiddle_00|Wst_Shooter_BlasterMiddle_01|Wst_Shooter_BlasterMiddle_H|Wst_Shooter_BlasterShort_00|Wst_Shooter_BlasterShort_01|Wst_Shooter_Blaze_00|Wst_Shooter_Blaze_01|Wst_Shooter_Expert_00|Wst_Shooter_Expert_01|Wst_Shooter_First_00|Wst_Shooter_First_01|Wst_Shooter_Flash_00|Wst_Shooter_Flash_01|Wst_Shooter_Gravity_00|Wst_Shooter_Gravity_01|Wst_Shooter_Heavy_00|Wst_Shooter_Heavy_01|Wst_Shooter_Long_00|Wst_Shooter_Long_01|Wst_Shooter_Normal_00|Wst_Shooter_Normal_01|Wst_Shooter_Normal_H|Wst_Shooter_Precision_00|Wst_Shooter_Precision_01|Wst_Shooter_QuickMiddle_00|Wst_Shooter_QuickMiddle_01|Wst_Shooter_Short_00|Wst_Shooter_Short_01|Wst_Shooter_TripleMiddle_00|Wst_Shooter_TripleMiddle_01|Wst_Shooter_TripleQuick_00|Wst_Shooter_TripleQuick_01|Wst_Slosher_Diffusion_00|Wst_Slosher_Diffusion_01|Wst_Slosher_Launcher_00|Wst_Slosher_Launcher_01|Wst_Slosher_Strong_00|Wst_Slosher_Strong_01|Wst_Slosher_Strong_H|Wst_Spinner_Hyper_00|Wst_Spinner_Hyper_01|Wst_Spinner_Quick_00|Wst_Spinner_Quick_01|Wst_Spinner_Standard_00|Wst_Spinner_Standard_01|Wst_Spinner_Standard_H|Wst_Twins_Dual_00|Wst_Twins_Dual_01|Wst_Twins_Gallon_00|Wst_Twins_Gallon_01|Wst_Twins_Normal_00|Wst_Twins_Normal_01|Wst_Twins_Normal_H|Wst_Twins_Short_00|Wst_Twins_Short_01|Wst_Twins_Stepper_00|Wst_Twins_Stepper_01|Wst_Umbrella_Normal_00|Wst_Umbrella_Normal_01|Wst_Umbrella_Normal_H";
//var strFileName = "Wst_Charger_Keeper_00|Wst_Charger_Keeper_01";
var arrFileNameTree = {};
var intArrFileNameMaxDepth = 0;
var rollNum = 1;
//var muteEn = false;
var STATE_SPINNING = 1;
var STATE_SLOT_STOP = 2;
/*
var STATE_SLOT1_STOP = 2;
var STATE_SLOT2_STOP = 3;
var STATE_SLOT3_STOP = 4;
*/
var STATE_STOPPED = 10;
var STATE_RESULTS = 11;
var STATE_END = 12;

var progressCount = 0; // current progress count
var progressTotalCount = 0; // total count
function updateProgress(inc) {
    progressCount += (inc || 1);
    if (progressCount >= progressTotalCount) {
        // done, complete progress bar and hide loading screen
        $('#progress').css('width', '100%');
        $('#loading').slideUp(600);
    } else {
        // Update progress bar
        $('#progress').css('width', parseInt(100 * progressCount / progressTotalCount) + '%');
    }
}

// Generic preloader handler, it calls preloadFunction for each item and
// passes function to it that it must call when done.
function preloader(items, preloadFunction, callback) {

    var itemc = 0;
    var loadc = 0;

    // called by preloadFunction to notify result
    function _check(err, id) {
        updateProgress(1);
        if (err) {
            alert('Failed to load ' + id + ': ' + err);
        }
        loadc++;
        if (itemc == loadc) callback();
    }

    if (items.constructor == Array) {
        itemc = items.length;
        loadc = 0;
        progressTotalCount += items.length;
        // queue each item for fetching
        items.forEach(function (item) {
            preloadFunction(item, _check);
        });
    } else {
        // object
        for (var key in items) {
            itemc++;
            progressTotalCount++;
            preloadFunction(items[key], _check);
        }
    }
}

// Images must be preloaded before they are used to draw into canvas
function preloadImages(images, callback) {

    preloader(images, _preload, callback);

    function _preload(asset, doneCallback) {
        asset.img = new Image();
        //asset.img.src = 'img/' + asset.path + '.png';
        asset.img.src = 'img/' + asset.path + '.png';

        asset.img.addEventListener("load", function () {
            doneCallback();
        }, false);

        asset.img.addEventListener("error", function (err) {
            doneCallback(err, asset.path);
        }, false);
    }
}

function _initWebAudio(AudioContext, format, audios, callback) {
    // See more details in http://www.html5rocks.com/en/tutorials/webaudio/intro/

    var context = new AudioContext();

    preloader(audios, _preload, callback);

    function _preload(asset, doneCallback) {
        var request = new XMLHttpRequest();
        request.open('GET', 'audio/' + asset.path + '.' + format, true);
        request.responseType = 'arraybuffer';

        request.onload = function () {
            context.decodeAudioData(request.response, function (buffer) {

                asset.play = function () {
                	if ($("#mute").val() == "0") {
                		var source = context.createBufferSource(); // creates a sound source
                		source.buffer = buffer;                    // tell the source which sound to play
                		source.connect(context.destination);       // connect the source to the context's destination (the speakers)
                		
                		// play the source now
                		// support both webkitAudioContext or standard AudioContext
                		source.noteOn ? source.noteOn(0) : source.start(0);						
					}
                };
                // default volume
                // support both webkitAudioContext or standard AudioContext
                asset.gain = context.createGain ? context.createGain() : context.createGainNode();
                asset.gain.connect(context.destination);
                asset.gain.gain.value = 0.5;

                doneCallback();

            }, function (err) {
                asset.play = function () {
                };
                doneCallback(err, asset.path);
            });
        };
        request.onerror = function (err) {
            console.log(err);
            asset.play = function () {
            };
            doneCallback(err, asset.path);
        };
        // kick off load
        request.send();
    }
}

function _initHTML5Audio(format, audios, callback) {

    preloader(audios, _preload, callback);

    function _preload(asset, doneCallback) {
        asset.audio = new Audio('audio/' + asset.path + '.' + format);
        asset.audio.preload = 'auto';
        asset.audio.addEventListener("loadeddata", function () {
            // Loaded ok, set play function in object and set default volume
            asset.play = function () {
                asset.audio.play();
            };
            asset.audio.volume = 0.6;

            doneCallback();
        }, false);

        asset.audio.addEventListener("error", function (err) {
            // Failed to load, set dummy play function
            asset.play = function () {
            }; // dummy

            doneCallback(err, asset.path);
        }, false);

    }
}

// Initializes audio and loads audio files
function initAudio(audios, callback) {

    var format = 'mp3';
    var elem = document.createElement('audio');
    if (elem) {
        // Check if we can play mp3, if not then fall back to ogg
        if (!elem.canPlayType('audio/mpeg;') && elem.canPlayType('audio/ogg;')) format = 'ogg';
    }

    var AudioContext = window.webkitAudioContext || window.mozAudioContext || window.MSAudioContext || window.AudioContext;

    if (AudioContext) {
        $('#audio_debug').text('WebAudio Supported');
        // Browser supports webaudio
        // https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
        return _initWebAudio(AudioContext, format, audios, callback);
    } else if (elem) {
        $('#audio_debug').text('HTML5 Audio Supported');
        // HTML5 Audio
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#the-audio-element
        return _initHTML5Audio(format, audios, callback);
    } else {
        $('#audio_debug').text('Audio NOT Supported');
        // audio not supported
        for (var key in audios) {
            audios[key].play = function () {
            }; // dummy play
        }
        callback();
    }
}

//var IMAGE_HEIGHT = 64;	//20180307 jili C
var IMAGE_HEIGHT = 128;	//20180307 jili C
var IMAGE_TOP_MARGIN = 5;
var IMAGE_BOTTOM_MARGIN = 5;
var SLOT_SEPARATOR_HEIGHT = 2;
var SLOT_HEIGHT = IMAGE_HEIGHT + IMAGE_TOP_MARGIN + IMAGE_BOTTOM_MARGIN + SLOT_SEPARATOR_HEIGHT; // how many pixels one slot image takes
var RUNTIME = 1500; // how long all slots spin before starting countdown
var SPINTIME = 800; // how long each slot spins at minimum
var ITEM_COUNT = 6; // item count in slots
var SLOT_SPEED = 30; // how many pixels per second slots roll
var DRAW_OFFSET = IMAGE_HEIGHT * 0.703125; // how much draw offset in slot display from top

var BLURB_TBL = [
    'No win!',
    'Good!',
    'Excellent!',
    'JACKPOT!'
];

function copyArray(array) {
    var copy = [];
    for (var i = 0; i < array.length; i++) {
        copy.push(array[i]);
    }
    return copy;
}

function shuffleArray(array) {
    var i;

    for (i = array.length - 1; i > 0; i--) {
        var j = parseInt(Math.random() * i);
        var tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}

function SlotGame() {
	var objForm = document.getElementById("form1");
	var arrFileName = [];
	var arrQueryString = getQueryString();
	var temp = splitImgNameToTree(strFileName);
	var strValueTemp;
	var boolAllFlag = false;
	var boolOneOfEachFlag = false;
	
	setFormParameter();
	splitImgNameToTree(strFileName);
	//var arrFileName = strFileName.split("|");
	debugger;
	
	
    var game = new Game();
    var items = [];
    
    /*
    var items = [
        {path: 'Classifiable/Wst_Shooter_Normal_H', id: 'reel1'},
        {path: 'Classifiable/Wst_Shooter_Normal_H', id: 'reel2'},
        {path: 'Classifiable/Wst_Shooter_Normal_H', id: 'reel3'},
        {path: 'Classifiable/Wst_Shooter_Normal_H', id: 'reel4'},
        {path: 'Classifiable/Wst_Shooter_Normal_H', id: 'reel5'},
        {path: 'Classifiable/Wst_Shooter_Normal_H', id: 'reel6'}
    ];
    */
    for (var i = 0; i < Object.keys(arrQueryString).length; i++) {
    	if (typeof(arrQueryString["type" + i]) != "undefined" && arrQueryString["type" + i] != null && arrQueryString["type" + i] != "All" && arrQueryString["type" + i] != "OneOfEach") {
    		add_hiddenElement(objForm, "type" + i, "type" + i, arrQueryString["type" + i]);
    		temp = temp[arrQueryString["type" + i]]
		} else if (arrQueryString["type" + i] == "All") {
    		add_hiddenElement(objForm, "type" + i, "type" + i, arrQueryString["type" + i]);
			boolAllFlag = true;
		} else if (arrQueryString["type" + i] == "OneOfEach") {
    		add_hiddenElement(objForm, "type" + i, "type" + i, arrQueryString["type" + i]);
    		boolOneOfEachFlag = true;
		} else {
			break;
		}
	}
    
    items = soltItems(items, temp, boolOneOfEachFlag)
    
    ITEM_COUNT = items.length;
    
    // Audio file names
    var audios = {
        'roll': {path: 'roll'}, // Played on roll start
        'reel1': {path: 'reels/reel-icon-1'}, // Played when reel stops on this icon
        'reel2': {path: 'reels/reel-icon-2'}, // Played when reel stops on this icon
        'reel3': {path: 'reels/reel-icon-3'}, // Played when reel stops on this icon
        'reel4': {path: 'reels/reel-icon-4'}, // Played when reel stops on this icon
        'reel5': {path: 'reels/reel-icon-5'}, // Played when reel stops on this icon
        'reel6': {path: 'reels/reel-icon-6'}, // Played when reel stops on this icon
        'win2': {path: '2ofaKind'}, // Played on 2 of a kind
        'win3': {path: '3ofaKind'}, // Played on 3 of a kind
        'nowin1': {path: '1TryAgain'},  // Played on 1 of a kind
        'nowin': {path: 'nowin'}  // Played on loss
    };

    var isMobile = (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase()));
    if(isMobile) {
        audios.intro = { path: 'SoundSlotsIntroMobile'};
    } else {
        audios.intro = { path: 'SoundSlotsIntro'};
    }

    $('canvas').attr('height', IMAGE_HEIGHT * ITEM_COUNT * 2);
    $('canvas').css('height', IMAGE_HEIGHT * ITEM_COUNT * 2);

    game.items = items;
    game.audios = audios;

    var imagesLoaded = false;
    var audioLoaded = false;

    // load assets and predraw the reel canvases

    initAudio(audios, function () {
        // audio is initialized and loaded
        audioLoaded = true;
        checkLoad();
    });

    preloadImages(items, function () {
        // images are preloaded
        imagesLoaded = true;
        checkLoad();
    });

    function checkLoad(IMAGE_HEIGHT) {
        if (!audioLoaded || !imagesLoaded) {
            return; // not yet ready
        }

        // all loaded

        // draws canvas strip
        function _fill_canvas(canvas, items, IMAGE_HEIGHT) {
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ddd';

            for (var i = 0; i < ITEM_COUNT; i++) {
                var asset = items[i];
                ctx.save();
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                ctx.shadowBlur = 5;
                ctx.drawImage(asset.img, 3, i * SLOT_HEIGHT + IMAGE_TOP_MARGIN);
                ctx.drawImage(asset.img, 3, (i + ITEM_COUNT) * SLOT_HEIGHT + IMAGE_TOP_MARGIN);
                ctx.restore();
                ctx.fillRect(0, i * SLOT_HEIGHT, IMAGE_HEIGHT, SLOT_SEPARATOR_HEIGHT);
                ctx.fillRect(0, (i + ITEM_COUNT) * SLOT_HEIGHT, IMAGE_HEIGHT, SLOT_SEPARATOR_HEIGHT);
            }
        }

        // Draw the canvases with shuffled arrays
        /*
        game.items1 = copyArray(items);
        shuffleArray(game.items1);
        _fill_canvas(game.c1[0], game.items1);
        
        game.items2 = copyArray(items);
        shuffleArray(game.items2);
        _fill_canvas(game.c2[0], game.items2);
        
        game.items3 = copyArray(items);
        shuffleArray(game.items3);
        _fill_canvas(game.c3[0], game.items3);
        */
        game.itemsX = [];
        for (var i = 0; i < 8; i++) {
			game.itemsX[i] = copyArray(items);
	        shuffleArray(game.itemsX[i]);
	        _fill_canvas(game.c[i][0], game.itemsX[i]);
		}
        
        game.resetOffset = (ITEM_COUNT + 3) * SLOT_HEIGHT;

        // Start game loop
        game.loop();

        // function starts game
        function _startRoll(e) {
        	rollNum = parseInt($('#rollNum option:selected').val());
        	if (rollNum < 3) {
        		rollNumFor_img_num = 3;
			} else {
				rollNumFor_img_num = rollNum;
			}
        	document.documentElement.style.setProperty('--img-num', rollNumFor_img_num);
        	for (var i = 0; i < 8; i++) {
        		if (i < rollNum) {
        			$('#canvas' + (i + 1)).show();				
				} else {
					$('#canvas' + (i + 1)).hide();
				}
			}
            $('h1').text('Rolling!');
            game.audios.roll.play();
            game.restart();
        }

        // start game on play button click
        $('#play').click(_startRoll);
        // start game on key press
        $(window).keypress(function (e) {
            if (e.which === 0 || e.which === 32) {
                // space button pressed
                e.preventDefault();
                _startRoll();
            }
        });

        // Play intro
        game.audios.intro.play();
    }


    // Show reels for debugging
    var toggleReels = 1;
    $('#debug').click(function () {
        toggleReels = 1 - toggleReels;
        if (toggleReels) {
            $('#reels').css('overflow', 'hidden');
        } else {
            $('#reels').css('overflow', 'visible');
        }
    });
}

function Game() {
	this.c = [];
	this.offset = [];
	this.speed = [];
	for (var i = 0; i < 8; i++) {
	    // reel canvases
		/*
	    this.c1 = $('#canvas1');
	    this.c2 = $('#canvas2');
	    this.c3 = $('#canvas3');
	    */
	    this.c.push($('#canvas'+(i+1)));
	
	    // set random canvas offsets
	    /*
	    this.offset1 = -parseInt(Math.random() * ITEM_COUNT) * SLOT_HEIGHT;
	    this.offset2 = -parseInt(Math.random() * ITEM_COUNT) * SLOT_HEIGHT;
	    this.offset3 = -parseInt(Math.random() * ITEM_COUNT) * SLOT_HEIGHT;
	    */
	    this.offset.push(-parseInt(Math.random() * ITEM_COUNT) * SLOT_HEIGHT);
	    //this.speed1 = this.speed2 = this.speed3 = 0;
	    this.speed.push(0);
	}
    this.lastUpdate = new Date();

    // Needed for CSS translates
    this.vendor =
        (/webkit/i).test(navigator.appVersion) ? '-webkit' :
            (/firefox/i).test(navigator.userAgent) ? '-moz' :
                (/msie/i).test(navigator.userAgent) ? 'ms' :
                    'opera' in window ? '-o' : '';

    this.cssTransform = this.vendor + '-transform';
    this.has3d = ('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix())
    this.trnOpen = 'translate' + (this.has3d ? '3d(' : '(');
    this.trnClose = this.has3d ? ',0)' : ')';
    this.scaleOpen = 'scale' + (this.has3d ? '3d(' : '(');
    this.scaleClose = this.has3d ? ',0)' : ')';

    // draw the slots to initial locations
    this.draw(true);
}

Game.prototype.setRandomResult = function ()
{
    /*
	this.result1 = parseInt(Math.random() * this.items1.length);
    this.result2 = parseInt(Math.random() * this.items2.length);
    this.result3 = parseInt(Math.random() * this.items3.length);
    */
	for (var i = 0; i < 8; i++) {
		this.result[i] = parseInt(Math.random() * this.itemsX[i].length);
	}
};

Game.prototype.setJackpotResult = function ()
{
    // function locates id from items
    function _find( items, id ) {
        for ( var i=0; i < items.length; i++ ) {
            if (items[i].id == id) return i;
        }
    }
    // Jackpot
    /*
    this.result1 = _find( this.items1, 'reel4' );
    this.result2 = _find( this.items2, 'reel4' );
    this.result3 = _find( this.items3, 'reel4' );
    */
    for (var i = 0; i < 8; i++) {
    	this.result[i] = _find( this.itemsX[i], 'reel4' );
	}
};

// Restart the game and determine the stopping locations for reels
Game.prototype.restart = function () {
    this.lastUpdate = new Date();
    //this.speed1 = this.speed2 = this.speed3 = SLOT_SPEED;
    for (var i = 0; i < 8; i++) {
    	this.speed[i] = SLOT_SPEED;
	}

    // get random results
    this.setRandomResult();

    // uncomment to override results with jackpot
    //this.setJackpotResult();
    
   for (var i = 0; i < 8; i++) {
	   // Clear stop locations
	   /*
	   this.stopped1 = false;
	   this.stopped2 = false;
	   this.stopped3 = false;
	   */
	   this.stopped[i] = false;
	   
	   // randomize reel locations
	   /*
	   this.offset1 = -parseInt(Math.random(ITEM_COUNT)) * SLOT_HEIGHT;
	   this.offset2 = -parseInt(Math.random(ITEM_COUNT)) * SLOT_HEIGHT;
	   this.offset3 = -parseInt(Math.random(ITEM_COUNT)) * SLOT_HEIGHT;
	   */
	   this.offset[i] = -parseInt(Math.random(ITEM_COUNT)) * SLOT_HEIGHT;
   }

    $('#results').hide();

    this.state = STATE_SPINNING;
};

window.requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (/* function */ callback, /* DOMElement */ element) {
            window.setTimeout(callback, 1000 / 60);
        };
})();

Game.prototype.loop = function () {
    var that = this;
    that.running = true;
    (function gameLoop() {
        that.update();
        that.draw();
        if (that.running) {
            requestAnimFrame(gameLoop);
        }
    })();
};

Game.prototype.checkWinLine = function()
{
    var matchCount = 0;

    // currently win is given only from icon #4
    /*
    if (this.items1[this.result1].id == 'reel4') matchCount++;
    if (this.items2[this.result2].id == 'reel4') matchCount++;
    if (this.items3[this.result3].id == 'reel4') matchCount++;
    */
    for (var i = 0; i < 8; i++) {
    	if (this.itemsX[i][this.result[i]].id == 'reel4') matchCount++;
	}

    return matchCount;
};

Game.prototype.update = function () {

    var now = new Date();
    var that = this;

    // Check slot status and if spun long enough stop it on result
    function _check_slot(offset, result) {
        if (now - that.lastUpdate > SPINTIME) {
            var c = parseInt(Math.abs(offset / SLOT_HEIGHT)) % ITEM_COUNT;
            if (c == result) {
                if (result == 0) {
                    if (Math.abs(offset + (ITEM_COUNT * SLOT_HEIGHT)) < (SLOT_SPEED * 1.5)) {
                        return true; // done
                    }
                } else if (Math.abs(offset + (result * SLOT_HEIGHT)) < (SLOT_SPEED * 1.5)) {
                    return true; // done
                }
            }
        }
        return false;
    }

    switch (this.state) {
        case STATE_SPINNING: // all slots spinning
            if (now - this.lastUpdate > RUNTIME) {
                this.state = STATE_SLOT_STOP;
                this.lastUpdate = now;
            }
            break;
        case 2: // slot 1
        case 3: // slot 2
        case 4: // slot 3
        case 5: // slot 4
        case 6: // slot 5
        case 7: // slot 6
        case 8: // slot 7
        case 9: // slot 8
        	stateTemp = this.state;
        	this.stopped[stateTemp - 2] = _check_slot(this.offset[stateTemp - 2], this.result[stateTemp - 2]);
            if (this.stopped[stateTemp - 2]) {
                this.speed[stateTemp - 2] = 0;
                if (stateTemp - 1 == rollNum) {
                	this.state = STATE_STOPPED;
                	this.lastUpdate = now;
				} else {
					this.state++; // advance to next slot
				}
                // play reel icon specific audio
                var id = this.itemsX[stateTemp - 2][this.result[stateTemp - 2]].id;
                this.audios[id].play();
            }
            break;
        /*
        case STATE_SLOT2_STOP: // slot 1 stopped, slot 2
            this.stopped2 = _check_slot(this.offset2, this.result2);
            if (this.stopped2) {
                this.speed2 = 0;
                this.state++; // advance to next slot
                this.lastUpdate = now;
                // play reel icon specific audio
                var id = this.items2[this.result2].id;
                this.audios[id].play();
            }
            break;
        case STATE_SLOT3_STOP: // slot 2 stopped, slot 3
            this.stopped3 = _check_slot(this.offset3, this.result3);
            if (this.stopped3) {
                this.speed3 = 0;
                this.state = STATE_STOPPED;
                // play reel icon specific audio
                var id = this.items3[this.result3].id;
                this.audios[id].play();
            }
            break;
        */
        case STATE_STOPPED: // slots stopped, wait for 2 seconds
            if (now - this.lastUpdate > 2000) {
                this.state = STATE_RESULTS;
            }
            break;
        case STATE_RESULTS: // check results
            var matches = this.checkWinLine();
            /*$('#results').show();*/
            $('#multiplier').text(matches);
            $('#status').text(BLURB_TBL[matches]);

            if (matches == 3) {
                // Play win sound
                this.audios.win3.play();
            } else if (matches == 2) {
                this.audios.win2.play();
            } else if (matches == 1) {
                // only one of a kind
                this.audios.nowin1.play();
            } else {
                // Play no-win sound
                this.audios.nowin.play();
            }

            this.state = STATE_END;
            break;
        case STATE_END: // game ends
        	$('h1').text('Splatoon 2 WeaponSlots');
            break;
        default:
    }
};

Game.prototype.result = [];
Game.prototype.stopped = [];
Game.prototype.draw = function (force) {

    if (this.state >= STATE_RESULTS) return;

    // draw the spinning slots based on current state
    for (var i = 0; i < 8; i++) {
        var resultp = 'result' + i;
        var stopped = 'stopped' + i;
        var speedp = 'speed' + i;
        var offsetp = 'offset' + i;
        var cp = 'c' + i;
        if (this.stopped[i] || this.speed[i] || force) {
            if (this.stopped[i]) {
                this.speed[i] = 0;
                var c = this.result[i]; // get stop location
                this.offset[i] = -(c * SLOT_HEIGHT);

                if (this.offset[i] + DRAW_OFFSET > 0) {
                    // reset back to beginning
                    this.offset[i] = -this.resetOffset + SLOT_HEIGHT * 3;
                }
            } else {
                this.offset[i] += this.speed[i];
                if (this.offset[i] + DRAW_OFFSET > 0) {
                    // reset back to beginning
                    this.offset[i] = -this.resetOffset + SLOT_HEIGHT * 3 - DRAW_OFFSET;
                }
            }
            // translate canvas location
            this.c[i].css(this.cssTransform, this.trnOpen + '0px, ' + (this.offset[i] + DRAW_OFFSET) + 'px' + this.trnClose);
        }
    }
};

function muteBtnClick() {
	if (parseInt($("#mute").val())) {
		$("#mute").val("0").change();
	} else {
		$("#mute").val("1").change();
	}
	muteChangeImg();
	//muteEn = !muteEn;
}

function muteChangeImg() {
	if (parseInt($("#mute").val())) {
		$("#muteBtn").attr("src","img/mute.png");
	} else {
		$("#muteBtn").attr("src","img/speaker.png");
	}
}

function getQueryString() {
	var strUrl = location.search;
	var getPara, ParaVal;
	var arrPara = [];
	
	if (strUrl.indexOf("?") != -1) {
		var getSearch = strUrl.split("?");
		getPara = getSearch[1].split("&");
		for (i = 0; i < getPara.length; i++) {
			ParaVal = getPara[i].split("=");
			//arrPara.push(ParaVal[0]);
			arrPara[ParaVal[0]] = ParaVal[1];
		}
	} else {
		arrPara["type0"] = "Wst";
	}
	return arrPara;
}

function setFormParameter(strKey, strValue) {
	var arrQueryString = getQueryString();
	if (strKey == null) {
		for ( var key in arrQueryString) {
			$("[name='"+key+"']").val(arrQueryString[key]).change();
		}		
	} else {
		$("[name='"+strKey+"']").val(strValue).change();
	}
	muteChangeImg();
}

function splitImgNameToTree(strFileNameTemp) {
	var arrFileName = strFileNameTemp.split("|");
	arrFileNameTree = {};
	for ( var i in arrFileName) {
		var arrTemp = arrFileName[i].split("_");	//["Wst", "Umbrella", "Normal", "H.png"]
		var strTemp = "arrFileNameTree";
		var strTempNewObj = "";
		var strTempObj = "arrFileNameTree";
		
		if (arrTemp.length > intArrFileNameMaxDepth) {
			intArrFileNameMaxDepth = arrTemp.length;
		}
		
		for ( var j in arrTemp) {
			if (arrTemp.length == parseInt(j) + 1) {
				//strTemp += "." + arrTemp[j];
				strTempObj += ".A" + arrTemp[j];	// 20180312 jili C 避免開頭第一個字為數字
				strTempNewObj += "if (typeof(" + strTempObj + ") == 'undefined') {" +
								"	" + strTempObj + " = {};" +
								"} ";
				strTemp += ".A" + arrTemp[j];
				strTemp += " = '" + arrFileName[i] + "';";
			} else {
				strTempObj += "." + arrTemp[j];
				strTempNewObj += "if (typeof(" + strTempObj + ") == 'undefined') {" +
								"	" + strTempObj + " = {};" +
								"} ";
				strTemp += "." + arrTemp[j];
			}
		}
		eval(strTempNewObj + strTemp);
	}
	return arrFileNameTree;
}

function settings_load() {
	var objForm = document.getElementById("form1");
	var arrFileName = splitImgNameToTree(strFileName);
	var arrQueryString = getQueryString();
	var temp = arrFileName;
	var strValueTemp;
	debugger;
	arrOptionValue1 = Object.keys(arrFileName);
	var strSelectName = "type0";
	setFormParameter();
	delegateFunOnChange = "selectOptionOnChange(0);";
	add_SelectElement(objForm, strSelectName, strSelectName, arrOptionValue1, arrOptionValue1, arrQueryString[strSelectName], delegateFunOnChange);
	
	for (var i = 1; i < intArrFileNameMaxDepth; i++) {
		strSelectName = "type" + (i - 1);
		var strSelectName1 = "type" + i;
		if (arrQueryString[strSelectName] == "All" || arrQueryString[strSelectName] == "OneOfEach" || arrQueryString[strSelectName] == "" || arrQueryString[strSelectName] == null) {
			arrOptionValue2 = [];
//			setFormParameter(strSelectName, document.getElementById(strSelectName).value);
		} else {
			arrOptionValue2 = ["All", "OneOfEach"].concat(Object.keys(temp[arrQueryString[strSelectName]]));
		}
		
		delegateFunOnChange = "selectOptionOnChange(" + i + ");";
		add_SelectElement(objForm, strSelectName1, strSelectName1, arrOptionValue2, arrOptionValue2, arrQueryString[strSelectName1], delegateFunOnChange);
//		if (arrOptionValue2 == []) {
			temp = temp[arrQueryString[strSelectName]];
//		}
//		setFormParameter(strSelectName);
	}
//	setFormParameter();
}

function add_hiddenElement(objForm, strHiddenId, strHiddenName, strHiddenValue)
{
	var new_element = document.createElement("input");
	new_element.id = strHiddenId;
	new_element.name = strHiddenName;
	new_element.type = "hidden";
	new_element.value = strHiddenValue;
	objForm.appendChild(new_element);
}

function add_SelectElement(objForm, strSelectId, strSelectName, arrOptionValue, arrOptionText_null, strDefaultValue, delegateFunOnChange)
{
	var new_element = document.createElement("select");
	new_element.id = strSelectId;
	new_element.name = strSelectName;
	//transport_select.setAttribute("onchange", function(){toggleSelect(transport_select_id);});
	new_element.setAttribute("onchange", delegateFunOnChange);
	add_option(new_element, arrOptionValue, arrOptionText_null, strDefaultValue);
	objForm.appendChild(new_element);
}

function add_option(objSelect, arrOptionValue, arrOptionText_null, strDefaultValue)
{
	var s = objSelect;
	
	for ( var i in arrOptionValue) {
		var t = getShowName(arrOptionText_null[i]);
		var v = arrOptionValue[i];
		var new_option = new Option(t,v);
		new_option.id = v;
		if (strDefaultValue == v) {
			new_option.selected = "selected";
		}
		s.options.add(new_option);		
	}
}

function getShowName(strOrgText) {
	var strLenguage = document.getElementById("lenguage").value;
	if (typeof(objShowName[strLenguage][strOrgText]) == "undefined") {
		return strOrgText;
	} else {
		return objShowName[strLenguage][strOrgText];
	}
}

function selectOptionOnChange(intTypeNum) {
//	var objSelect = document.getElementById("type" + intTypeNum);
	var boolAllFlag = false;
//	objSelect.value;
	var temp = arrFileNameTree;
	for (var i = 0; i <= intTypeNum; i++) {
//		if (typeof(temp[document.getElementById("type" + intTypeNum).value]) == "undefined") {
//			break;
//		}
		if (typeof(document.getElementById("type" + i).value) == "undefined") {
			boolAllFlag = true;
			break;
		}
		//[...select.options].filter(option => option.selected).map(option => option.value)
		temp = temp[document.getElementById("type" + i).value];
	}
	
	for (var j = i; j < intArrFileNameMaxDepth; j++) {
		document.getElementById("type" + j).options.length = 0;
	}
	
	if (!boolAllFlag && typeof(temp) != "string") {
		add_option(document.getElementById("type" + i), ["All", "OneOfEach"].concat(Object.keys(temp)), ["All", "OneOfEach"].concat(Object.keys(temp)))
	}
}

function languageBtnClick(strLanguage) {
	document.getElementById("lenguage").value = strLanguage;
	for ( var key in objShowName[strLanguage]) {
		if (document.getElementById(key) != null) {
			document.getElementById(key).text = objShowName[strLanguage][key];
		}
	}
}

function soltItems(items, object, boolOneOfEachFlag) {
	if(typeof object == 'string'){
		items.push({path: "Classifiable/" + object, id:"reel" + (Math.floor(Math.random() * (6 - 1 + 1)) + 1)});
	} else {
		var key;
		for(key in object) {
			if(typeof object[key] == 'string'){
				items.push({path: "Classifiable/" + object[key], id:"reel" + (Math.floor(Math.random() * (6 - 1 + 1)) + 1)})
				if (boolOneOfEachFlag) {
					return items;
				} else {
					continue;
				}
			}
				
			if(typeof object[key] == 'object'){
				items = soltItems(items, object[key], boolOneOfEachFlag);
			}
		}
	}
	return items;
}